from __future__ import absolute_import, annotations

from copy import deepcopy
from typing import List

import cv2 as cv
import numpy as np


class StandardImageOperations:

    ratio = 3  # we can try to set a high threshold instead of using this ratio
    kernel_size = 3  # we can try to understand what is that
    scale = 1
    delta = 0
    depth = cv.CV_16S
    n_derivative = 2
    percentage = 85

    @staticmethod
    def rescale_image(image_to_rescale: np.ndarray, target_number_of_pixels: int = 100000) -> np.ndarray:
        """
        Rescale the image to a target number of pixels
        """

        scale = (len(image_to_rescale[0]) * len(image_to_rescale) / target_number_of_pixels) ** (1 / 2)
        return cv.resize(image_to_rescale, (0, 0), fx=(1 / scale), fy=(1 / scale))

    @staticmethod
    def grab_contours(contour_tuple: tuple) -> List[np.ndarray]:
        """
        Grab a list contours from the tuple resulting from cv.findContours
        """

        # for OpenCV v2.4, v4-official
        if len(contour_tuple) == 2:
            return contour_tuple[0]
        # for OpenCV v3
        elif len(contour_tuple) == 3:
            return contour_tuple[1]

    @staticmethod
    def find_best_threshold(greyscale_image):
        canny_on_previous_threshold = StandardImageOperations.canny_elements(greyscale_image, 25)
        canny_previous_delta = StandardImageOperations.canny_elements(greyscale_image, 24) - canny_on_previous_threshold
        picked_threshold = 0
        for i in range(26, 1000):
            canny_on_new_threshold = StandardImageOperations.canny_elements(greyscale_image, i)
            canny_new_delta = canny_on_previous_threshold - canny_on_new_threshold
            canny_on_previous_threshold = canny_on_new_threshold
            if (canny_new_delta + canny_previous_delta) < 50:
                picked_threshold = i
                break
            canny_previous_delta = canny_new_delta
        return picked_threshold

    @staticmethod
    def canny_edges(greyscale_image: np.ndarray, low_threshold: int) -> np.ndarray:
        """
        Apply canny edge detector and return the edges
        """

        greyscale_blurred_image = cv.GaussianBlur(greyscale_image, (3, 3), 0)
        return cv.Canny(greyscale_blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)

    @staticmethod
    def canny_elements(greyscale_image: np.ndarray, low_threshold: int) -> int:
        """
        Apply canny edge detector and return the sum of elements in the mask generated by the edges
        """

        greyscale_blurred_image = cv.GaussianBlur(greyscale_image, (3, 3), 0)
        detected_edges = cv.Canny(greyscale_blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)
        mask = detected_edges != 0
        return np.ma.sum(mask)

    @staticmethod
    def canny_on_image(greyscale_image: np.ndarray, low_threshold: int, original_image: np.ndarray) -> np.ndarray:
        """
        Apply canny edge detector and return the edges on the original image
        """

        greyscale_blurred_image = cv.GaussianBlur(greyscale_image, (3, 3), 0)
        detected_edges = cv.Canny(greyscale_blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)
        mask = detected_edges != 0
        return original_image * (mask[:, :, None].astype(original_image.dtype))

    @staticmethod
    def sobel_edges(greyscale_image: np.ndarray) -> np.ndarray:
        """
        Apply sobel edge detector and return the edges
        """

        greyscale_blurred_image = cv.GaussianBlur(greyscale_image, (3, 3), 0)
        gradient_x = cv.Sobel(greyscale_blurred_image, StandardImageOperations.depth, StandardImageOperations.n_derivative, 0, ksize=StandardImageOperations.kernel_size,
                              scale=StandardImageOperations.scale, delta=StandardImageOperations.delta, borderType=cv.BORDER_DEFAULT)
        gradient_y = cv.Sobel(greyscale_blurred_image, StandardImageOperations.depth, 0, StandardImageOperations.n_derivative, ksize=StandardImageOperations.kernel_size,
                              scale=StandardImageOperations.scale, delta=StandardImageOperations.delta, borderType=cv.BORDER_DEFAULT)
        abs_gradient_x = cv.convertScaleAbs(gradient_x)
        abs_gradient_y = cv.convertScaleAbs(gradient_y)
        gradient_image = cv.addWeighted(abs_gradient_x, 0.5, abs_gradient_y, 0.5, 0)
        kernel = np.ones((3, 3), np.uint8)
        close_after_sobel = cv.morphologyEx(gradient_image, cv.MORPH_CLOSE, kernel)
        return cv.morphologyEx(close_after_sobel, cv.MORPH_OPEN, kernel)

    @staticmethod
    def remove_percentile(greyscale_image: np.ndarray) -> np.ndarray:
        """
        Remove percentile from a grey scale image
        """

        positive_values_array = []
        for i, item_i in enumerate(greyscale_image):
            for j, item_j in enumerate(item_i):
                if item_j > 0:
                    positive_values_array.append(item_j)
        percentile = np.percentile(positive_values_array, StandardImageOperations.percentage)

        image_without_percentile = deepcopy(greyscale_image)
        for i, item_i in enumerate(greyscale_image):
            for j, item_j in enumerate(item_i):
                if item_j <= percentile:
                    image_without_percentile[i, j] = 0

        return image_without_percentile

    @staticmethod
    def apply_hsv_mask(original_image: np.ndarray, hsv_image: np.ndarray, lower_bound: np.ndarray, upper_bound: np.ndarray) -> np.ndarray:
        """
        Apply an hsv mask based on a range of hsv colors on the original image
        """

        mask = cv.inRange(hsv_image, lower_bound, upper_bound)
        # mask = cv.morphologyEx(mask, cv.MORPH_OPEN, (5, 5), iterations=1)
        return cv.bitwise_and(original_image, original_image, mask=mask)

    @staticmethod
    def get_hsv_mask(original_image: np.ndarray, hsv_image: np.ndarray, color: str) -> np.ndarray:
        """
        Applying an hsv mask based on a color of interest on the original image
        """

        if color == "f":
            lower_bound = np.array([0, 0, 50])
            upper_bound = np.array([35, 255, 255])
            lower_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            lower_bound = np.array([75, 0, 50])
            upper_bound = np.array([90, 255, 255])
            upper_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            lower_image = cv.bitwise_or(lower_image, upper_image)
            lower_bound = np.array([110, 0, 50])
            upper_bound = np.array([179, 255, 255])
            upper_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            return cv.bitwise_or(lower_image, upper_image)
        elif color == "l":
            lower_bound = np.array([20, 0, 0])
            upper_bound = np.array([80, 255, 255])
        elif color == "b":
            lower_bound = np.array([0, 0, 0])
            upper_bound = np.array([30, 255, 255])
        else:
            lower_bound = np.array([0, 0, 0])
            upper_bound = np.array([180, 255, 255])
        return StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
