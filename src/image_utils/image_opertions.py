from __future__ import absolute_import, annotations

from typing import List

import cv2 as cv
import numpy as np


class StandardImageOperations:

    ratio = 3  # we can try to set a high threshold instead of using this ratio
    kernel_size = 3  # we can try to understand what is that

    @staticmethod
    def rescale_image(image_to_rescale: np.ndarray, target_number_of_pixels: int = 100000) -> np.ndarray:
        """
        Rescale the image to a target number of pixels
        """

        scale = (len(image_to_rescale[0]) * len(image_to_rescale) / target_number_of_pixels) ** (1 / 2)
        return cv.resize(image_to_rescale, (0, 0), fx=(1 / scale), fy=(1 / scale))

    @staticmethod
    def grab_contours(contour_tuple: tuple) -> List[np.ndarray]:
        """
        Grab a list contours from the tuple resulting from cv.findContours
        """

        # for OpenCV v2.4, v4-official
        if len(contour_tuple) == 2:
            return contour_tuple[0]
        # for OpenCV v3
        elif len(contour_tuple) == 3:
            return contour_tuple[1]

    @staticmethod
    def canny_edges(greyscale_image: np.ndarray, low_threshold: int) -> np.ndarray:
        """
        Apply canny edge detector and return the edges
        """

        blurred_image = cv.blur(greyscale_image, (3, 3))
        return cv.Canny(blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)

    @staticmethod
    def canny_elements(greyscale_image: np.ndarray, low_threshold: int) -> int:
        """
        Apply canny edge detector and return the sum of elements in the mask generated by the edges
        """

        blurred_image = cv.blur(greyscale_image, (3, 3))
        detected_edges = cv.Canny(blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)
        mask = detected_edges != 0
        return np.ma.sum(mask)

    @staticmethod
    def canny_on_image(greyscale_image: np.ndarray, low_threshold: int, original_image: np.ndarray) -> np.ndarray:
        """
        Apply canny edge detector and return the edges on the original image
        """

        blurred_image = cv.blur(greyscale_image, (3, 3))
        detected_edges = cv.Canny(blurred_image, low_threshold, low_threshold * StandardImageOperations.ratio, StandardImageOperations.kernel_size)
        mask = detected_edges != 0
        return original_image * (mask[:, :, None].astype(original_image.dtype))

    @staticmethod
    def apply_hsv_mask(original_image: np.ndarray, hsv_image: np.ndarray, lower_bound: np.ndarray, upper_bound: np.ndarray) -> np.ndarray:
        """
        Apply an hsv mask based on a range of hsv colors on the original image
        """

        mask = cv.inRange(hsv_image, lower_bound, upper_bound)
        # mask = cv.morphologyEx(mask, cv.MORPH_OPEN, (5, 5), iterations=1)
        return cv.bitwise_and(original_image, original_image, mask=mask)

    @staticmethod
    def get_hsv_mask(original_image: np.ndarray, hsv_image: np.ndarray, color: str) -> np.ndarray:
        """
        Applying an hsv mask based on a color of interest on the original image
        """

        if color == "w":
            lower_bound = np.array([0, 0, 50])
            upper_bound = np.array([35, 255, 255])
            lower_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            lower_bound = np.array([75, 0, 50])
            upper_bound = np.array([90, 255, 255])
            upper_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            lower_image = cv.bitwise_or(lower_image, upper_image)
            lower_bound = np.array([110, 0, 50])
            upper_bound = np.array([179, 255, 255])
            upper_image = StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
            return cv.bitwise_or(lower_image, upper_image)
        elif color == "g":
            lower_bound = np.array([20, 0, 0])
            upper_bound = np.array([80, 255, 255])
        elif color == "b":
            lower_bound = np.array([0, 0, 0])
            upper_bound = np.array([30, 255, 255])
        else:
            lower_bound = np.array([0, 0, 0])
            upper_bound = np.array([180, 255, 255])
        return StandardImageOperations.apply_hsv_mask(original_image, hsv_image, lower_bound, upper_bound)
